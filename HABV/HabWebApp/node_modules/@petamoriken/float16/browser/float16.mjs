/*! @petamoriken/float16 v3.5.0 | MIT License - https://git.io/float16 */

// algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf

const buffer = new ArrayBuffer(4);
const floatView = new Float32Array(buffer);
const uint32View = new Uint32Array(buffer);

const baseTable = new Uint32Array(512);
const shiftTable = new Uint32Array(512);

for (let i = 0; i < 256; ++i) {
  const e = i - 127;

  // very small number (0, -0)
  if (e < -27) {
    baseTable[i]         = 0x0000;
    baseTable[i | 0x100] = 0x8000;
    shiftTable[i]         = 24;
    shiftTable[i | 0x100] = 24;

  // small number (denorm)
  } else if (e < -14) {
    baseTable[i]         =  0x0400 >> (-e - 14);
    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
    shiftTable[i]         = -e - 1;
    shiftTable[i | 0x100] = -e - 1;

  // normal number
  } else if (e <= 15) {
    baseTable[i]         =  (e + 15) << 10;
    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
    shiftTable[i]         = 13;
    shiftTable[i | 0x100] = 13;

  // large number (Infinity, -Infinity)
  } else if (e < 128) {
    baseTable[i]         = 0x7c00;
    baseTable[i | 0x100] = 0xfc00;
    shiftTable[i]         = 24;
    shiftTable[i | 0x100] = 24;

  // stay (NaN, Infinity, -Infinity)
  } else {
    baseTable[i]         = 0x7c00;
    baseTable[i | 0x100] = 0xfc00;
    shiftTable[i]         = 13;
    shiftTable[i | 0x100] = 13;
  }
}

/**
 * round a number to a half float number bits.
 *
 * @param {number} num - double float
 * @returns {number} half float number bits
 */
function roundToFloat16Bits(num) {
  floatView[0] = num;
  const f = uint32View[0];
  const e = (f >> 23) & 0x1ff;
  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);
}

const mantissaTable = new Uint32Array(2048);
const exponentTable = new Uint32Array(64);
const offsetTable = new Uint32Array(64);

mantissaTable[0] = 0;
for (let i = 1; i < 1024; ++i) {
  let m = i << 13;    // zero pad mantissa bits
  let e = 0;          // zero exponent

  // normalized
  while((m & 0x00800000) === 0) {
    e -= 0x00800000;  // decrement exponent
    m <<= 1;
  }

  m &= ~0x00800000;   // clear leading 1 bit
  e += 0x38800000;    // adjust bias

  mantissaTable[i] = m | e;
}
for (let i = 1024; i < 2048; ++i) {
  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
}

exponentTable[0] = 0;
for (let i = 1; i < 31; ++i) {
  exponentTable[i] = i << 23;
}
exponentTable[31] = 0x47800000;
exponentTable[32] = 0x80000000;
for (let i = 33; i < 63; ++i) {
  exponentTable[i] = 0x80000000 + ((i - 32) << 23);
}
exponentTable[63] = 0xc7800000;

offsetTable[0] = 0;
for (let i = 1; i < 64; ++i) {
  if (i === 32) {
    offsetTable[i] = 0;
  } else {
    offsetTable[i] = 1024;
  }
}

/**
 * convert a half float number bits to a number.
 *
 * @param {number} float16bits - half float number bits
 * @returns {number} double float
 */
function convertToNumber(float16bits) {
  const m = float16bits >> 10;
  uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 0x3ff)] + exponentTable[m];
  return floatView[0];
}

/**
 * returns the nearest half precision float representation of a number.
 *
 * @param {number} num
 * @returns {number}
 */
function hfround(num) {
  if (typeof num === "bigint") {
    throw TypeError("Cannot convert a BigInt value to a number");
  }

  num = Number(num);

  // for optimization
  if (!Number.isFinite(num) || num === 0) {
    return num;
  }

  const x16 = roundToFloat16Bits(num);
  return convertToNumber(x16);
}

/** @returns {(self: object) => object} */
function createPrivateStorage() {
  const wm = new WeakMap();

  return (self) => {
    const storage = wm.get(self);
    if (storage !== undefined) {
      return storage;
    }

    const obj = Object.create(null);
    wm.set(self, obj);
    return obj;
  };
}

const _$1 = createPrivateStorage();

const IteratorPrototype = Reflect.getPrototypeOf(Reflect.getPrototypeOf([][Symbol.iterator]()));

/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */
const ArrayIteratorPrototype = Object.create(IteratorPrototype, {
  next: {
    value: function next() {
      return _$1(this).iterator.next();
    },
    writable: true,
    configurable: true,
  },

  [Symbol.toStringTag]: {
    value: "Array Iterator",
    configurable: true,
  },
});

/**
 * @param {Iterator<T>} iterator
 * @returns {IterableIterator<T>}
 */
function wrapInArrayIterator(iterator) {
  const arrayIterator = Object.create(ArrayIteratorPrototype);
  _$1(arrayIterator).iterator = iterator;
  return arrayIterator;
}

/**
 * @param {unknown} value
 * @returns {value is object}
 */
function isObject(value) {
  return (value !== null && typeof value === "object") || typeof value === "function";
}

/**
 * @param {unknown} value
 * @returns {value is object}
 */
function isObjectLike(value) {
  return value !== null && typeof value === "object";
}

// Inspired by util.types implementation of Node.js
const getTypedArrayPrototypeSymbolToStringTag = Reflect.getOwnPropertyDescriptor(Reflect.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;

/**
 * @param {unknown} value
 * @returns {value is Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array}
 */
function isTypedArray(value) {
  return getTypedArrayPrototypeSymbolToStringTag.call(value) !== undefined;
}

/**
 * @param {unknown} value
 * @returns {value is Uint16Array}
 */
function isUint16Array(value) {
  return getTypedArrayPrototypeSymbolToStringTag.call(value) === "Uint16Array";
}

/**
 * @param {unknown} value
 * @returns {value is BigInt64Array|BigUint64Array}
 */
function isBigIntTypedArray(value) {
  const typedArrayName = getTypedArrayPrototypeSymbolToStringTag.call(value);
  return typedArrayName === "BigInt64Array" || typedArrayName === "BigUint64Array";
}

/**
 * @param {unknown} value
 * @returns {value is DataView}
 */
function isDataView(value) {
  if (!ArrayBuffer.isView(value)) {
    return false;
  }

  if (isTypedArray(value)) {
    return false;
  }

  return true;
}

/**
 * @param {unknown} value
 * @returns {value is ArrayBuffer}
 */
function isArrayBuffer(value) {
  return isObjectLike(value) && value[Symbol.toStringTag] === "ArrayBuffer";
}

/**
 * @param {unknown} value
 * @returns {value is SharedArrayBuffer}
 */
function isSharedArrayBuffer(value) {
  return isObjectLike(value) && value[Symbol.toStringTag] === "SharedArrayBuffer";
}

/**
 * @param {unknown} value
 * @returns {value is Iterable<any>}
 */
function isIterable(value) {
  return isObject(value) && typeof value[Symbol.iterator] === "function";
}

/**
 * @param {unknown} value
 * @returns {value is any[]}
 */
function isOrdinaryArray(value) {
  if (!Array.isArray(value)) {
    return false;
  }

  const iterator = value[Symbol.iterator]();
  if (iterator[Symbol.toStringTag] !== "Array Iterator") {
    return false;
  }

  return true;
}

/**
 * @param {unknown} value
 * @returns {value is Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array}
 */
function isOrdinaryTypedArray(value) {
  if (!isTypedArray(value)) {
    return false;
  }

  const iterator = value[Symbol.iterator]();
  if (iterator[Symbol.toStringTag] !== "Array Iterator") {
    return false;
  }

  return true;
}

/**
 * @param {unknown} value
 * @returns {value is string}
 */
function isCanonicalIntegerIndexString(value) {
  if (typeof value !== "string") {
    return false;
  }

  const number = Number(value);
  if (value !== number + "") {
    return false;
  }

  if (!Number.isFinite(number)) {
    return false;
  }

  if (number !== Math.trunc(number)) {
    return false;
  }

  return true;
}

/**
 * @see https://tc39.es/ecma262/#sec-tointegerorinfinity
 * @param {unknown} target
 * @returns {number}
 */
function ToIntegerOrInfinity(target) {
  if (typeof target === "bigint") {
    throw TypeError("Cannot convert a BigInt value to a number");
  }

  const number = Number(target);

  if (Number.isNaN(number) || number === 0) {
    return 0;
  }

  return Math.trunc(number);
}

/**
 * @see https://tc39.es/ecma262/#sec-tolength
 * @param {unknown} target
 * @returns {number}
 */
function ToLength(target) {
  const length = ToIntegerOrInfinity(target);
  if (length < 0) {
    return 0;
  }

  return length < Number.MAX_SAFE_INTEGER ? length : Number.MAX_SAFE_INTEGER;
}

/**
 * @see https://tc39.es/ecma262/#sec-lengthofarraylike
 * @param {object} arrayLike
 * @returns {number}
 */
function LengthOfArrayLike(arrayLike) {
  if (!isObject(arrayLike)) {
    throw TypeError("This is not a object");
  }

  return ToLength(arrayLike.length);
}

/**
 * @see https://tc39.es/ecma262/#sec-speciesconstructor
 * @param {object} target
 * @param {Function} defaultConstructor
 * @returns {Function}
 */
function SpeciesConstructor(target, defaultConstructor) {
  if (!isObject(target)) {
    throw TypeError("This is not a object");
  }

  const constructor = target.constructor;
  if (constructor === undefined) {
    return defaultConstructor;
  }
  if (!isObject(constructor)) {
    throw TypeError("Constructor is not a object");
  }

  const species = constructor[Symbol.species];
  if (species == null) {
    return defaultConstructor;
  }

  return species;
}

/**
 * bigint comparisons are not supported
 *
 * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
 * @param {number} x
 * @param {number} y
 * @returns {-1 | 0 | 1}
 */
function defaultCompare(x, y) {
  const isNaN_x = Number.isNaN(x);
  const isNaN_y = Number.isNaN(y);

  if (isNaN_x && isNaN_y) {
    return 0;
  }

  if (isNaN_x) {
    return 1;
  }

  if (isNaN_y) {
    return -1;
  }

  if (x < y) {
    return -1;
  }

  if (x > y) {
    return 1;
  }

  if (x === 0 && y === 0) {
    const isPlusZero_x = Object.is(x, 0);
    const isPlusZero_y = Object.is(y, 0);

    if (!isPlusZero_x && isPlusZero_y) {
      return -1;
    }

    if (isPlusZero_x && !isPlusZero_y) {
      return 1;
    }
  }

  return 0;
}

const hasOwnProperty = Object.prototype.hasOwnProperty;

/** @type {(object: object, key: PropertyKey) => boolean} */
const hasOwn = Object.hasOwn || function hasOwn(object, key) {
  return hasOwnProperty.call(object, key);
};

const brand = Symbol.for("__Float16Array__");

const _ = createPrivateStorage();

/**
 * @param {unknown} target
 * @returns {boolean}
 */
function hasFloat16ArrayBrand(target) {
  if (!isObjectLike(target)) {
    return false;
  }

  const prototype = Reflect.getPrototypeOf(target);
  if (!isObjectLike(prototype)) {
    return false;
  }

  const constructor = prototype.constructor;
  if (constructor === undefined) {
    return false;
  }
  if (!isObject(constructor)) {
    throw TypeError("Constructor is not a object");
  }

  return Reflect.has(constructor, brand);
}

/**
 * @param {unknown} target
 * @returns {target is Float16Array}
 */
function isFloat16Array(target) {
  return hasFloat16ArrayBrand(target) && !isTypedArray(target);
}

/**
 * @param {unknown} target
 * @returns {target is Uint16Array & { __float16bits: never }}
 */
function isFloat16BitsArray(target) {
  return hasFloat16ArrayBrand(target) && isUint16Array(target);
}

/**
 * @param {unknown} target
 * @throws {TypeError}
 */
function assertFloat16Array(target) {
  if (!isFloat16Array(target)) {
    throw new TypeError("This is not a Float16Array");
  }
}

/**
 * @param {unknown} target
 * @throws {TypeError}
 */
function assertSpeciesTypedArray(target) {
  if (isFloat16Array(target)) {
    return;
  }

  if (!isTypedArray(target)) {
    throw new TypeError("SpeciesConstructor didn't return TypedArray");
  }

  if (isBigIntTypedArray(target)) {
    throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
  }
}

/**
 * @param {Float16Array} float16
 * @returns {Uint16Array & { __float16bits: never }}
 */
function getFloat16BitsArray(float16) {
  let target = _(float16).target;

  // from other realms
  if (target === undefined) {
    const clone = new Float16Array(float16.buffer, float16.byteOffset, float16.length);
    target = _(clone).target;
  }

  return target;
}

/**
 * @param {Uint16Array & { __float16bits: never }} float16bitsArray
 * @returns {number[]}
 */
function copyToArray(float16bitsArray) {
  const length = float16bitsArray.length;

  const array = [];
  for (let i = 0; i < length; ++i) {
    array[i] = convertToNumber(float16bitsArray[i]);
  }

  return array;
}

const TypedArrayPrototype = Reflect.getPrototypeOf(Uint8Array).prototype;

const TypedArrayPrototypeGetters = new Set();
for (const key of Reflect.ownKeys(TypedArrayPrototype)) {
  const descriptor = Object.getOwnPropertyDescriptor(TypedArrayPrototype, key);
  if (hasOwn(descriptor, "get")) {
    TypedArrayPrototypeGetters.add(key);
  }
}

/** @type {ProxyHandler<Float16Array>} */
const handler = Object.freeze({
  get(target, key, receiver) {
    if (isCanonicalIntegerIndexString(key) && hasOwn(target, key)) {
      return convertToNumber(Reflect.get(target, key));
    }

    if (TypedArrayPrototypeGetters.has(key)) {
      return Reflect.get(target, key);
    }

    return Reflect.get(target, key, receiver);
  },

  set(target, key, value, receiver) {
    if (isCanonicalIntegerIndexString(key) && hasOwn(target, key)) {
      return Reflect.set(target, key, roundToFloat16Bits(value));
    }

    return Reflect.set(target, key, value, receiver);
  },
});

/** limitation: `Object.getPrototypeOf(Float16Array)` returns `Uint16Array` */
class Float16Array extends Uint16Array {

  /** @see https://tc39.es/ecma262/#sec-typedarray */
  constructor(input, byteOffset, length) {
    // input Float16Array
    if (isFloat16Array(input)) {
      // peel off Proxy
      const float16bitsArray = getFloat16BitsArray(input);
      super(float16bitsArray);

    // object without ArrayBuffer
    } else if (isObject(input) && !isArrayBuffer(input)) {
      /** @type {ArrayLike<number>} */
      let list;
      /** @type {number} */
      let length;

      // TypedArray
      if (isTypedArray(input)) {
        if (isBigIntTypedArray(input)) {
          throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
        }

        list = input;
        length = input.length;

        const buffer = input.buffer;
        /** @type {ArrayBufferConstructor} */
        const BufferConstructor = !isSharedArrayBuffer(buffer) ? SpeciesConstructor(buffer, ArrayBuffer) : ArrayBuffer;
        const data = new BufferConstructor(length * Float16Array.BYTES_PER_ELEMENT);
        super(data);

      // Iterable (Array)
      } else if (isIterable(input)) {
        // for optimization
        if (isOrdinaryArray(input)) {
          list = input;
          length = input.length;
          super(length);

        } else {
          list = [...input];
          length = list.length;
          super(length);
        }

      // ArrayLike
      } else {
        list = input;
        length = LengthOfArrayLike(input);
        super(length);
      }

      // set values
      for (let i = 0; i < length; ++i) {
        // super (Uint16Array)
        this[i] = roundToFloat16Bits(list[i]);
      }

    // primitive, ArrayBuffer
    } else {
      switch (arguments.length) {
        case 0:
          super();
          break;

        case 1:
          super(input);
          break;

        case 2:
          super(input, byteOffset);
          break;

        case 3:
          super(input, byteOffset, length);
          break;

        default:
          super(...arguments);
      }
    }

    const proxy = new Proxy(this, handler);

    // proxy private storage
    _(proxy).target = this;

    return proxy;
  }

  /**
   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
   *
   * @see https://tc39.es/ecma262/#sec-%typedarray%.from
   */
  static from(src, ...opts) {
    const Constructor = this;

    if (!Reflect.has(Constructor, brand)) {
      throw TypeError("This constructor is not a subclass of Float16Array");
    }

    // for optimization
    if (Constructor === Float16Array) {
      if (isFloat16Array(src) && opts.length === 0) {
        const uint16 = new Uint16Array(src.buffer, src.byteOffset, src.length);
        return new Float16Array(uint16.slice().buffer);
      }

      if (opts.length === 0) {
        return new Float16Array(Uint16Array.from(src, roundToFloat16Bits).buffer);
      }

      const mapFunc = opts[0];
      const thisArg = opts[1];

      return new Float16Array(Uint16Array.from(src, function (val, ...args) {
        return roundToFloat16Bits(mapFunc.call(this, val, ...args));
      }, thisArg).buffer);
    }

    /** @type {ArrayLike<number>} */
    let list;
    /** @type {number} */
    let length;

    // Iterable (TypedArray, Array)
    if (isIterable(src)) {
      // for optimization
      if (isOrdinaryArray(src) || isOrdinaryTypedArray(src)) {
        list = src;
        length = src.length;
      } else {
        list = [...src];
        length = list.length;
      }

    // ArrayLike
    } else {
      list = src;
      length = LengthOfArrayLike(src);
    }

    const array = new Constructor(length);

    if (opts.length === 0) {
      for (let i = 0; i < length; ++i) {
        array[i] = list[i];
      }

    } else {
      const mapFunc = opts[0];
      const thisArg = opts[1];
      for (let i = 0; i < length; ++i) {
        array[i] = mapFunc.call(thisArg, list[i], i);
      }
    }

    return array;
  }

  /**
   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
   *
   * @see https://tc39.es/ecma262/#sec-%typedarray%.of
   */
  static of(...items) {
    const Constructor = this;

    if (!Reflect.has(Constructor, brand)) {
      throw TypeError("This constructor is not a subclass of Float16Array");
    }

    const length = items.length;

    // for optimization
    if (Constructor === Float16Array) {
      const proxy = new Float16Array(length);
      const float16bitsArray = getFloat16BitsArray(proxy);

      for (let i = 0; i < length; ++i) {
        float16bitsArray[i] = roundToFloat16Bits(items[i]);
      }

      return proxy;
    }

    const array = new Constructor(length);

    for (let i = 0; i < length; ++i) {
      array[i] = items[i];
    }

    return array;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys */
  keys() {
    assertFloat16Array(this);

    return Reflect.apply(super.keys, getFloat16BitsArray(this), []);
  }

  /**
   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
   *
   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
   */
  values() {
    assertFloat16Array(this);

    const arrayIterator = Reflect.apply(super.values, getFloat16BitsArray(this), []);
    return wrapInArrayIterator((function* () {
      for (const val of arrayIterator) {
        yield convertToNumber(val);
      }
    })());
  }

  /**
   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
   *
   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
   */
  entries() {
    assertFloat16Array(this);

    const arrayIterator = Reflect.apply(super.entries, getFloat16BitsArray(this), []);
    return wrapInArrayIterator((function* () {
      for (const [i, val] of arrayIterator) {
        yield [i, convertToNumber(val)];
      }
    })());
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.at */
  at(index) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    const relativeIndex = ToIntegerOrInfinity(index);
    const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;

    if (k < 0 || k >= length) {
      return;
    }

    return convertToNumber(float16bitsArray[k]);
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.map */
  map(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    const thisArg = opts[0];

    const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);

    // for optimization
    if (Constructor === Float16Array) {
      const proxy = new Float16Array(length);
      const array = getFloat16BitsArray(proxy);

      for (let i = 0; i < length; ++i) {
        const val = convertToNumber(float16bitsArray[i]);
        array[i] = roundToFloat16Bits(callback.call(thisArg, val, i, this));
      }

      return proxy;
    }

    const array = new Constructor(length);
    assertSpeciesTypedArray(array);

    for (let i = 0; i < length; ++i) {
      const val = convertToNumber(float16bitsArray[i]);
      array[i] = callback.call(thisArg, val, i, this);
    }

    return array;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter */
  filter(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    const thisArg = opts[0];

    const kept = [];
    for (let i = 0; i < length; ++i) {
      const val = convertToNumber(float16bitsArray[i]);
      if (callback.call(thisArg, val, i, this)) {
        kept.push(val);
      }
    }

    const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);
    const array = new Constructor(kept);
    assertSpeciesTypedArray(array);

    return array;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce */
  reduce(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    if (length === 0 && opts.length === 0) {
      throw TypeError("Reduce of empty array with no initial value");
    }

    let accumulator, start;
    if (opts.length === 0) {
      accumulator = convertToNumber(float16bitsArray[0]);
      start = 1;
    } else {
      accumulator = opts[0];
      start = 0;
    }

    for (let i = start; i < length; ++i) {
      accumulator = callback(accumulator, convertToNumber(float16bitsArray[i]), i, this);
    }

    return accumulator;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright */
  reduceRight(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    if (length === 0 && opts.length === 0) {
      throw TypeError("Reduce of empty array with no initial value");
    }

    let accumulator, start;
    if (opts.length === 0) {
      accumulator = convertToNumber(float16bitsArray[length - 1]);
      start = length - 2;
    } else {
      accumulator = opts[0];
      start = length - 1;
    }

    for (let i = start; i >= 0; --i) {
      accumulator = callback(accumulator, convertToNumber(float16bitsArray[i]), i, this);
    }

    return accumulator;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach */
  forEach(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    const thisArg = opts[0];

    for (let i = 0; i < length; ++i) {
      callback.call(thisArg, convertToNumber(float16bitsArray[i]), i, this);
    }
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.find */
  find(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    const thisArg = opts[0];

    for (let i = 0; i < length; ++i) {
      const value = convertToNumber(float16bitsArray[i]);
      if (callback.call(thisArg, value, i, this)) {
        return value;
      }
    }
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex */
  findIndex(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    const thisArg = opts[0];

    for (let i = 0; i < length; ++i) {
      const value = convertToNumber(float16bitsArray[i]);
      if (callback.call(thisArg, value, i, this)) {
        return i;
      }
    }

    return -1;
  }

  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlast */
  findLast(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    const thisArg = opts[0];

    for (let i = length - 1; i >= 0; --i) {
      const value = convertToNumber(float16bitsArray[i]);
      if (callback.call(thisArg, value, i, this)) {
        return value;
      }
    }
  }

  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlastindex */
  findLastIndex(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    const thisArg = opts[0];

    for (let i = length - 1; i >= 0; --i) {
      const value = convertToNumber(float16bitsArray[i]);
      if (callback.call(thisArg, value, i, this)) {
        return i;
      }
    }

    return -1;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.every */
  every(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    const thisArg = opts[0];

    for (let i = 0; i < length; ++i) {
      if (!callback.call(thisArg, convertToNumber(float16bitsArray[i]), i, this)) {
        return false;
      }
    }

    return true;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.some */
  some(callback, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;
    const thisArg = opts[0];

    for (let i = 0; i < length; ++i) {
      if (callback.call(thisArg, convertToNumber(float16bitsArray[i]), i, this)) {
        return true;
      }
    }

    return false;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.set */
  set(input, ...opts) {
    assertFloat16Array(this);

    const targetOffset = ToIntegerOrInfinity(opts[0]);
    if (targetOffset < 0) {
      throw RangeError("Offset is out of bounds");
    }

    if (isBigIntTypedArray(input)) {
      throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
    }

    // for optimization
    if (isFloat16Array(input)) {
      // peel off Proxy
      return Reflect.apply(super.set, getFloat16BitsArray(this), [
        getFloat16BitsArray(input),
        targetOffset,
      ]);
    }

    const float16bitsArray = getFloat16BitsArray(this);

    const targetLength = float16bitsArray.length;

    const src = Object(input);
    const srcLength = LengthOfArrayLike(src);

    if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {
      throw RangeError("Offset is out of bounds");
    }

    for (let i = 0; i < srcLength; ++i) {
      float16bitsArray[i + targetOffset] = roundToFloat16Bits(src[i]);
    }
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse */
  reverse() {
    assertFloat16Array(this);

    Reflect.apply(super.reverse, getFloat16BitsArray(this), []);

    return this;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill */
  fill(value, ...opts) {
    assertFloat16Array(this);

    Reflect.apply(super.fill, getFloat16BitsArray(this), [roundToFloat16Bits(value), ...opts]);

    return this;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin */
  copyWithin(target, start, ...opts) {
    assertFloat16Array(this);

    Reflect.apply(super.copyWithin, getFloat16BitsArray(this), [target, start, ...opts]);

    return this;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort */
  sort(...opts) {
    assertFloat16Array(this);

    const compare = opts[0] !== undefined ? opts[0] : defaultCompare;
    Reflect.apply(super.sort, getFloat16BitsArray(this), [(x, y) => { return compare(convertToNumber(x), convertToNumber(y)); }]);

    return this;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice */
  slice(...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);

    // for optimization
    if (Constructor === Float16Array) {
      const uint16 = new Uint16Array(float16bitsArray.buffer, float16bitsArray.byteOffset, float16bitsArray.length);
      return new Float16Array(uint16.slice(...opts).buffer);
    }

    const length = float16bitsArray.length;
    const start = ToIntegerOrInfinity(opts[0]);
    const end = opts[1] === undefined ? length : ToIntegerOrInfinity(opts[1]);

    let k;
    if (start === -Infinity) {
      k = 0;
    } else if (start < 0) {
      k = length + start > 0 ? length + start : 0;
    } else {
      k = length < start ? length : start;
    }

    let final;
    if (end === -Infinity) {
      final = 0;
    } else if (end < 0) {
      final = length + end > 0 ? length + end : 0;
    } else {
      final = length < end ? length : end;
    }

    const count = final - k > 0 ? final - k : 0;
    const array = new Constructor(count);
    assertSpeciesTypedArray(array);

    if (count === 0) {
      return array;
    }

    let n = 0;
    while (k < final) {
      array[n] = convertToNumber(float16bitsArray[k]);
      ++k;
      ++n;
    }

    return array;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray */
  subarray(...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);

    const uint16 = new Uint16Array(float16bitsArray.buffer, float16bitsArray.byteOffset, float16bitsArray.length);
    const uint16Subarray = uint16.subarray(...opts);

    const array = new Constructor(uint16Subarray.buffer, uint16Subarray.byteOffset, uint16Subarray.length);
    assertSpeciesTypedArray(array);

    return array;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof */
  indexOf(element, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;

    let from = ToIntegerOrInfinity(opts[0]);
    if (from === Infinity) {
      return -1;
    }

    if (from < 0) {
      from += length;
      if (from < 0) {
        from = 0;
      }
    }

    for (let i = from; i < length; ++i) {
      if (hasOwn(float16bitsArray, i) && convertToNumber(float16bitsArray[i]) === element) {
        return i;
      }
    }

    return -1;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof */
  lastIndexOf(element, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;

    let from = opts.length >= 1 ? ToIntegerOrInfinity(opts[0]) : length - 1;
    if (from === -Infinity) {
      return -1;
    }

    if (from >= 0) {
      from = from < length - 1 ? from : length - 1;
    } else {
      from += length;
    }

    for (let i = from; i >= 0; --i) {
      if (hasOwn(float16bitsArray, i) && convertToNumber(float16bitsArray[i]) === element) {
        return i;
      }
    }

    return -1;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes */
  includes(element, ...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);

    const length = float16bitsArray.length;

    let from = ToIntegerOrInfinity(opts[0]);
    if (from === Infinity) {
      return false;
    }

    if (from < 0) {
      from += length;
      if (from < 0) {
        from = 0;
      }
    }

    const isNaN = Number.isNaN(element);
    for (let i = from; i < length; ++i) {
      const value = convertToNumber(float16bitsArray[i]);

      if (isNaN && Number.isNaN(value)) {
        return true;
      }

      if (value === element) {
        return true;
      }
    }

    return false;
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.join */
  join(...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);
    const array = copyToArray(float16bitsArray);

    return array.join(...opts);
  }

  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring */
  toLocaleString(...opts) {
    assertFloat16Array(this);

    const float16bitsArray = getFloat16BitsArray(this);
    const array = copyToArray(float16bitsArray);

    return array.toLocaleString(...opts);
  }

  /** @see https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag */
  get [Symbol.toStringTag]() {
    if (isFloat16BitsArray(this)) {
      return "Float16Array";
    }
  }
}

/** @see https://tc39.es/ecma262/#sec-typedarray.bytes_per_element */
Object.defineProperty(Float16Array, "BYTES_PER_ELEMENT", { value: Uint16Array.BYTES_PER_ELEMENT });

/** limitation: It is peaked by `Object.getOwnPropertySymbols(Float16Array)` and `Reflect.ownKeys(Float16Array)` */
Object.defineProperty(Float16Array, brand, {});

const Float16ArrayPrototype = Float16Array.prototype;

/** @see https://tc39.es/ecma262/#sec-typedarray.prototype.bytes_per_element */
Object.defineProperty(Float16ArrayPrototype, "BYTES_PER_ELEMENT", { value: Uint16Array.BYTES_PER_ELEMENT });

/** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator */
Object.defineProperty(Float16ArrayPrototype, Symbol.iterator, {
  value: Float16ArrayPrototype.values,
  writable: true,
  configurable: true,
});

// To make `new Float16Array() instanceof Uint16Array` returns `false`
Reflect.setPrototypeOf(Float16ArrayPrototype, TypedArrayPrototype);

/**
 * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView.
 *
 * @param {DataView} dataView
 * @param {number} byteOffset
 * @param {[boolean]} opts
 * @returns {number}
 */
function getFloat16(dataView, byteOffset, ...opts) {
  if (!isDataView(dataView)) {
    throw new TypeError("First argument to getFloat16 must be a DataView");
  }

  return convertToNumber( dataView.getUint16(byteOffset, ...opts) );
}

/**
 * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView.
 *
 * @param {DataView} dataView
 * @param {number} byteOffset
 * @param {number} value
 * @param {[boolean]} opts
 */
function setFloat16(dataView, byteOffset, value, ...opts) {
  if (!isDataView(dataView)) {
    throw new TypeError("First argument to setFloat16 must be a DataView");
  }

  dataView.setUint16(byteOffset, roundToFloat16Bits(value), ...opts);
}

export { Float16Array, getFloat16, hfround, isFloat16Array, setFloat16 };
