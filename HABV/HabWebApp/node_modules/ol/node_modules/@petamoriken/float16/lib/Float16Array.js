"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _spec = require("./spec");

var _is = require("./is");

var _private = require("./private");

var _memoize = _interopRequireDefault(require("lodash/memoize"));

var _lib = require("./lib");

var _bug = require("./bug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const _ = (0, _private.createPrivateStorage)();

function isFloat16Array(target) {
  return target instanceof Float16Array;
}

function assertFloat16Array(target) {
  if (!isFloat16Array(target)) {
    throw new TypeError("This is not a Float16Array");
  }
}

function isDefaultFloat16ArrayMethods(target) {
  return typeof target === "function" && defaultFloat16ArrayMethods.has(target);
}

function copyToArray(float16bits) {
  const length = float16bits.length;
  const array = new Array(length);

  for (let i = 0; i < length; ++i) {
    array[i] = (0, _lib.convertToNumber)(float16bits[i]);
  }

  return array;
} // proxy handler


const applyHandler = {
  apply(func, thisArg, args) {
    // peel off proxy
    if (isFloat16Array(thisArg) && isDefaultFloat16ArrayMethods(func)) return Reflect.apply(func, _(thisArg).target, args);
    return Reflect.apply(func, thisArg, args);
  }

};
const handler = {
  get(target, key) {
    let wrapper = null;

    if (!_bug.isTypedArrayIndexedPropertyWritable) {
      wrapper = target;
      target = _(wrapper).target;
    }

    if ((0, _is.isStringNumberKey)(key)) {
      return Reflect.has(target, key) ? (0, _lib.convertToNumber)(Reflect.get(target, key)) : undefined;
    } else {
      const ret = wrapper !== null && Reflect.has(wrapper, key) ? Reflect.get(wrapper, key) : Reflect.get(target, key);
      if (typeof ret !== "function") return ret; // TypedArray methods can't be called by Proxy Object

      let proxy = _(ret).proxy;

      if (proxy === undefined) {
        proxy = _(ret).proxy = new Proxy(ret, applyHandler);
      }

      return proxy;
    }
  },

  set(target, key, value) {
    let wrapper = null;

    if (!_bug.isTypedArrayIndexedPropertyWritable) {
      wrapper = target;
      target = _(wrapper).target;
    }

    if ((0, _is.isStringNumberKey)(key)) {
      return Reflect.set(target, key, (0, _lib.roundToFloat16Bits)(value));
    } else {
      // frozen object can't change prototype property
      if (wrapper !== null && (!Reflect.has(target, key) || Object.isFrozen(wrapper))) {
        return Reflect.set(wrapper, key, value);
      } else {
        return Reflect.set(target, key, value);
      }
    }
  }

};

if (!_bug.isTypedArrayIndexedPropertyWritable) {
  handler.getPrototypeOf = wrapper => Reflect.getPrototypeOf(_(wrapper).target);

  handler.setPrototypeOf = (wrapper, prototype) => Reflect.setPrototypeOf(_(wrapper).target, prototype);

  handler.defineProperty = (wrapper, key, descriptor) => {
    const target = _(wrapper).target;

    return !Reflect.has(target, key) || Object.isFrozen(wrapper) ? Reflect.defineProperty(wrapper, key, descriptor) : Reflect.defineProperty(target, key, descriptor);
  };

  handler.deleteProperty = (wrapper, key) => {
    const target = _(wrapper).target;

    return Reflect.has(wrapper, key) ? Reflect.deleteProperty(wrapper, key) : Reflect.deleteProperty(target, key);
  };

  handler.has = (wrapper, key) => Reflect.has(wrapper, key) || Reflect.has(_(wrapper).target, key);

  handler.isExtensible = wrapper => Reflect.isExtensible(wrapper);

  handler.preventExtensions = wrapper => Reflect.preventExtensions(wrapper);

  handler.getOwnPropertyDescriptor = (wrapper, key) => Reflect.getOwnPropertyDescriptor(wrapper, key);

  handler.ownKeys = wrapper => Reflect.ownKeys(wrapper);
}

class Float16Array extends Uint16Array {
  constructor(input, byteOffset, length) {
    // input Float16Array
    if (isFloat16Array(input)) {
      super(_(input).target); // 22.2.1.3, 22.2.1.4 TypedArray, Array, ArrayLike, Iterable
    } else if (input !== null && typeof input === "object" && !(0, _is.isArrayBuffer)(input)) {
      // if input is not ArrayLike and Iterable, get Array
      const arrayLike = !Reflect.has(input, "length") && input[Symbol.iterator] !== undefined ? [...input] : input;
      const length = arrayLike.length;
      super(length);

      for (let i = 0; i < length; ++i) {
        // super (Uint16Array)
        this[i] = (0, _lib.roundToFloat16Bits)(arrayLike[i]);
      } // 22.2.1.2, 22.2.1.5 primitive, ArrayBuffer

    } else {
      switch (arguments.length) {
        case 0:
          super();
          break;

        case 1:
          super(input);
          break;

        case 2:
          super(input, byteOffset);
          break;

        case 3:
          super(input, byteOffset, length);
          break;

        default:
          super(...arguments);
      }
    }

    let proxy;

    if (_bug.isTypedArrayIndexedPropertyWritable) {
      proxy = new Proxy(this, handler);
    } else {
      const wrapper = Object.create(null);
      _(wrapper).target = this;
      proxy = new Proxy(wrapper, handler);
    } // proxy private storage


    _(proxy).target = this; // this private storage

    _(this).proxy = proxy;
    return proxy;
  } // static methods


  static from(src) {
    if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) return new Float16Array(Uint16Array.from(src, _lib.roundToFloat16Bits).buffer);
    const mapFunc = arguments.length <= 1 ? undefined : arguments[1];
    const thisArg = arguments.length <= 2 ? undefined : arguments[2];
    return new Float16Array(Uint16Array.from(src, function (val) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (0, _lib.roundToFloat16Bits)(mapFunc.call(this, val, ...args));
    }, thisArg).buffer);
  }

  static of() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return new Float16Array(args);
  } // iterate methods


  *[Symbol.iterator]() {
    for (const val of super[Symbol.iterator]()) {
      yield (0, _lib.convertToNumber)(val);
    }
  }

  keys() {
    return super.keys();
  }

  *values() {
    for (const val of super.values()) {
      yield (0, _lib.convertToNumber)(val);
    }
  }

  *entries() {
    for (const [i, val] of super.entries()) {
      yield [i, (0, _lib.convertToNumber)(val)];
    }
  } // functional methods


  map(callback) {
    assertFloat16Array(this);
    const thisArg = arguments.length <= 1 ? undefined : arguments[1];
    const array = [];

    for (let i = 0, l = this.length; i < l; ++i) {
      const val = (0, _lib.convertToNumber)(this[i]);
      array.push(callback.call(thisArg, val, i, _(this).proxy));
    }

    return new Float16Array(array);
  }

  filter(callback) {
    assertFloat16Array(this);
    const thisArg = arguments.length <= 1 ? undefined : arguments[1];
    const array = [];

    for (let i = 0, l = this.length; i < l; ++i) {
      const val = (0, _lib.convertToNumber)(this[i]);

      if (callback.call(thisArg, val, i, _(this).proxy)) {
        array.push(val);
      }
    }

    return new Float16Array(array);
  }

  reduce(callback) {
    assertFloat16Array(this);
    let val, start;

    if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {
      val = (0, _lib.convertToNumber)(this[0]);
      start = 1;
    } else {
      val = arguments.length <= 1 ? undefined : arguments[1];
      start = 0;
    }

    for (let i = start, l = this.length; i < l; ++i) {
      val = callback(val, (0, _lib.convertToNumber)(this[i]), i, _(this).proxy);
    }

    return val;
  }

  reduceRight(callback) {
    assertFloat16Array(this);
    let val, start;
    const length = this.length;

    if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {
      val = (0, _lib.convertToNumber)(this[length - 1]);
      start = length - 1;
    } else {
      val = arguments.length <= 1 ? undefined : arguments[1];
      start = length;
    }

    for (let i = start; i--;) {
      val = callback(val, (0, _lib.convertToNumber)(this[i]), i, _(this).proxy);
    }

    return val;
  }

  forEach(callback) {
    assertFloat16Array(this);
    const thisArg = arguments.length <= 1 ? undefined : arguments[1];

    for (let i = 0, l = this.length; i < l; ++i) {
      callback.call(thisArg, (0, _lib.convertToNumber)(this[i]), i, _(this).proxy);
    }
  }

  find(callback) {
    assertFloat16Array(this);
    const thisArg = arguments.length <= 1 ? undefined : arguments[1];

    for (let i = 0, l = this.length; i < l; ++i) {
      const value = (0, _lib.convertToNumber)(this[i]);
      if (callback.call(thisArg, value, i, _(this).proxy)) return value;
    }
  }

  findIndex(callback) {
    assertFloat16Array(this);
    const thisArg = arguments.length <= 1 ? undefined : arguments[1];

    for (let i = 0, l = this.length; i < l; ++i) {
      const value = (0, _lib.convertToNumber)(this[i]);
      if (callback.call(thisArg, value, i, _(this).proxy)) return i;
    }

    return -1;
  }

  every(callback) {
    assertFloat16Array(this);
    const thisArg = arguments.length <= 1 ? undefined : arguments[1];

    for (let i = 0, l = this.length; i < l; ++i) {
      if (!callback.call(thisArg, (0, _lib.convertToNumber)(this[i]), i, _(this).proxy)) return false;
    }

    return true;
  }

  some(callback) {
    assertFloat16Array(this);
    const thisArg = arguments.length <= 1 ? undefined : arguments[1];

    for (let i = 0, l = this.length; i < l; ++i) {
      if (callback.call(thisArg, (0, _lib.convertToNumber)(this[i]), i, _(this).proxy)) return true;
    }

    return false;
  } // change element methods


  set(input) {
    assertFloat16Array(this);
    const offset = arguments.length <= 1 ? undefined : arguments[1];
    let float16bits; // input Float16Array

    if (isFloat16Array(input)) {
      float16bits = _(input).target; // input others
    } else {
      const arrayLike = !Reflect.has(input, "length") && input[Symbol.iterator] !== undefined ? [...input] : input;
      const length = arrayLike.length;
      float16bits = new Uint16Array(length);

      for (let i = 0, l = arrayLike.length; i < l; ++i) {
        float16bits[i] = (0, _lib.roundToFloat16Bits)(arrayLike[i]);
      }
    }

    super.set(float16bits, offset);
  }

  reverse() {
    assertFloat16Array(this);
    super.reverse();
    return _(this).proxy;
  }

  fill(value) {
    assertFloat16Array(this);

    for (var _len3 = arguments.length, opts = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      opts[_key3 - 1] = arguments[_key3];
    }

    super.fill((0, _lib.roundToFloat16Bits)(value), ...opts);
    return _(this).proxy;
  }

  copyWithin(target, start) {
    assertFloat16Array(this);

    for (var _len4 = arguments.length, opts = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
      opts[_key4 - 2] = arguments[_key4];
    }

    super.copyWithin(target, start, ...opts);
    return _(this).proxy;
  }

  sort() {
    assertFloat16Array(this);
    let compareFunction = arguments.length <= 0 ? undefined : arguments[0];

    if (compareFunction === undefined) {
      compareFunction = _spec.defaultCompareFunction;
    }

    const _convertToNumber = (0, _memoize.default)(_lib.convertToNumber);

    super.sort((x, y) => compareFunction(_convertToNumber(x), _convertToNumber(y)));
    return _(this).proxy;
  } // copy element methods


  slice() {
    assertFloat16Array(this);
    let float16bits; // V8, SpiderMonkey, JavaScriptCore, Chakra throw TypeError

    try {
      float16bits = super.slice(...arguments);
    } catch (e) {
      if (e instanceof TypeError) {
        const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);
        float16bits = uint16.slice(...arguments);
      } else {
        throw e;
      }
    }

    return new Float16Array(float16bits.buffer);
  }

  subarray() {
    assertFloat16Array(this);
    let float16bits; // V8, SpiderMonkey, JavaScriptCore, Chakra throw TypeError

    try {
      float16bits = super.subarray(...arguments);
    } catch (e) {
      if (e instanceof TypeError) {
        const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);
        float16bits = uint16.subarray(...arguments);
      } else {
        throw e;
      }
    }

    return new Float16Array(float16bits.buffer, float16bits.byteOffset, float16bits.length);
  } // contains methods


  indexOf(element) {
    assertFloat16Array(this);
    const length = this.length;
    let from = (0, _spec.ToInteger)(arguments.length <= 1 ? undefined : arguments[1]);

    if (from < 0) {
      from += length;
      if (from < 0) from = 0;
    }

    for (let i = from, l = length; i < l; ++i) {
      if ((0, _lib.convertToNumber)(this[i]) === element) return i;
    }

    return -1;
  }

  lastIndexOf(element) {
    assertFloat16Array(this);
    const length = this.length;
    let from = (0, _spec.ToInteger)(arguments.length <= 1 ? undefined : arguments[1]);
    from = from === 0 ? length : from + 1;

    if (from >= 0) {
      from = from < length ? from : length;
    } else {
      from += length;
    }

    for (let i = from; i--;) {
      if ((0, _lib.convertToNumber)(this[i]) === element) return i;
    }

    return -1;
  }

  includes(element) {
    assertFloat16Array(this);
    const length = this.length;
    let from = (0, _spec.ToInteger)(arguments.length <= 1 ? undefined : arguments[1]);

    if (from < 0) {
      from += length;
      if (from < 0) from = 0;
    }

    const isNaN = Number.isNaN(element);

    for (let i = from, l = length; i < l; ++i) {
      const value = (0, _lib.convertToNumber)(this[i]);
      if (isNaN && Number.isNaN(value)) return true;
      if (value === element) return true;
    }

    return false;
  } // string methods


  join() {
    assertFloat16Array(this);
    const array = copyToArray(this);
    return array.join(...arguments);
  }

  toLocaleString() {
    assertFloat16Array(this);
    const array = copyToArray(this);
    return array.toLocaleString(...arguments);
  }

  get [Symbol.toStringTag]() {
    if (isFloat16Array(this)) return "Float16Array";
  }

}

exports.default = Float16Array;
const Float16Array$prototype = Float16Array.prototype;
const defaultFloat16ArrayMethods = new WeakSet();

for (const key of Reflect.ownKeys(Float16Array$prototype)) {
  const val = Float16Array$prototype[key];
  if (typeof val === "function") defaultFloat16ArrayMethods.add(val);
}

module.exports = exports.default;